# Aeron

## 背景

目前的技术架构，为减少程序耦合，采用了[`aeron-rs`](https://github.com/UnitedTraders/aeron-rs)进行跨进程间通信；其中采用其共享内存的机制。因为Aeron协议是设计直接跑多种传输介质的，包含了共享内存/IPC, infiniBand/RDMA,UDP,TCP,Raw IP,HTTP,WebSocket,BLE。因此Aeron基于以下假设：

- 传输介质可以是流媒体，例如 TCP 或 RDMA，而没有固有的帧边界。
- 传输介质可能仅具有单播模式。
- 长度为 16 位及以上的字段采用小端序。这主要是为了在对性能要求较高的平台上提高效率。由于字节被视为原子单位，因此无需考虑子字节序。

Aeron作为传输协议，可以在不可靠的介质上运行，作为OSI传输层（物理层/数据链路层/网络层/传输层/会话层/表示层/应用层）提供可靠的面向连接的数据流。因此必须接受一些额外的假设，Aeron会检测并纠正这些假设，例如：

- 可能会出现数据包重复的情况。
- 数据包可能会丢失。
- 包裹可能乱序送达。

因此，使用了基于日志的持久化存储，Publication和Subscription都基于内存映射文件。消息发送就可以追加到日志文件中，消费从日志文件中读取。类似于数据库的WAL的持久化保证。如果要追求极致的低延迟，还是需要显示配置允许丢消息（不发NAK消息，reliable=false）。

因此Aeron本身产生问题，通常和系统配置有关。常见排查步骤如下：

1.查看Aeron日志

2.查看空间状态`df -h /dev/shm`

3.检查系统参数`sysctl vm.max_map_count`和`ipcs -ls`

4.使用`aeron-stat`来诊断流状态和内部计数器。

## 高性能和高并发

核心思想：最大化顺序I/O,最小化竞争，零拷贝

每个Publication对应一个日志文件，只有一个写入者（线程）。因此可以完全无锁。且追加日志是最快的I/O模式而不是随机寻址。

零拷贝：共享内存+mmap+write。aeron通过共享内存和环形队列实现低延迟的数据传输。
