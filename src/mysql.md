# MySQL

## 性能

主键：必须用自增整型，避免UUID，订单表主键order_id,用户表user_id，确保顺序查询，防止页分裂。

联合索引：多条件查询的 “性能核心”，是多个字段组合而成的索引，遵循「最左前缀匹配原则」—— 索引会按字段顺序依次排序，查询时仅能匹配 “从左到右的连续前缀”，跳过前缀会导致索引失效（全表扫描）。

覆盖索引：包含查询所需所有字段的索引——查询时仅需扫描索引即可返回结果，无需回表（二次查询聚簇索引），是 InnoDB 查询性能的 “天花板优化”。

MySQL 8.0 + 支持INCLUDE子句（仅包含字段，不参与排序），低版本需将字段加入索引；

索引为 idx_user_symbol_include (user_id, symbol) INCLUDE (position_volume, avg_price)

原逻辑：SELECT symbol, position_volume, avg_price FROM position WHERE user_id=123 → 回表（IO 2 次），耗时 10ms；覆盖索引仅扫描索引（IO 1 次），耗时 1ms。

## 强一致性

资金、订单、持仓的状态必须实时同步，无歧义（比如挂单后必须立即冻结，避免超仓；成交后，持仓必须立即更新，不能出现成交后持仓无变化的场景）

数据库的ACID特性：Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性）

关于事务的隔离性：

- 读未提交（Read Uncommitted）：允许一个事务读取另一个事务未提交的数据，可能导致脏读（Dirty Read）。脏读就是一个事务读取到了另一个事务未提交的数据。
- 读已提交（Read Committed）：一个事务只能读取已提交的数据，避免脏读，但可能导致不可重复读（Non-repeatable Read）。
- 可重复读（Repeatable Read）：在一个事务中，多次读取同一数据，结果保持一致，避免不可重复读，但可能导致幻读（Phantom Read）。
- 串行化（Serializable）：最高级别的隔离，事务按顺序执行，避免所有并发问题。

RR的实现： MVCC（多版本并发控制），undo log 版本链、 Read View

锁机制：行级锁（FOR UPDATE/ROLLBACK），间隙锁/Nexy-Key Lock（解决幻读）

交易所：资金扣减必须加行级锁 + 乐观锁，避免并发超扣。

而交易所核心流程常跨多个模块（"下单"需更新订单表+资金表+持仓表，可能分布在不同的数据库），此时单数据库无法满足一致性，可能是由多个事务组成，需结合：

个人理解这种做法就是并不是加上你的钱，而是先给你加上一个冻结的钱（当然也要和当前的可用的钱进行判断）

- TCC(Try-Confirm-Cancel)
    Try 冻结用户保证金（本地事务）。
    Confirm: 扣减保证金+生成订单（本地事务，RR级别）。
    Cancel: 解冻保证金。

- Saga模式
    拆分分布式事务为多个本地事务，失败时执行补偿逻辑（如订单创建失败，回滚资金扣减）。

- 高并发核心表
    TPS极高，仅靠数据库事务不够，需结合：内存优先，分库分表，缓存+数据库双写。

## 7x24小时高可用

集群部署、主从切换（比如数据库主从、撮合引擎多实例）、异地容灾（多地域部署，避免单地域故障）

无停机部署（灰度发布、蓝绿部署）、故障自动恢复（服务熔断、降级、比如非核心功能故障时，优先保证撮合和资金功能）、监控告警（实时监控系统状态，故障秒级发现）

## 安全性

DDos攻击：采用负载均衡、防火墙、CDN等技术，防止攻击流量 overwhelming数据库。

SQL注入攻击：对用户输入进行严格校验和转义，避免恶意SQL代码执行。本质就是对用户输入没有做用户参数进行校验。可以使用参数化查询来完全杜绝注入。

## 同步类型（交易所安全性优先级）

|同步类型|原理|优点|缺点|交易所选型|
|--|--|--|--|--|
|异步同步|主库提交事务后立即返回，不等待从库同步|性能最高|主库宕机可能丢数据|非核心表（日志）|
|半同步同步|主库提交后，等待至少 1 个从库接收 binlog,仅丢 1 个事务|安全性高|性能下降 10%-20%|核心表（资金 / 订单）|
|全同步同步|主库等待所有从库执行完 binlog 才返回|零数据丢失|性能下降 50%+|清算库（低并发）|
